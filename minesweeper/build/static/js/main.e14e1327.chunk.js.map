{"version":3,"sources":["reducers/tiles.js","components/Tile.jsx","components/Row.jsx","components/Gameboard.jsx","containers/GameboardContainer.jsx","actions/index.js","App.js","serviceWorker.js","index.js"],"names":["generateInitialState","initialTiles","i","push","j","containsMine","clicked","mineLocations","length","potentialLocation","Math","floor","random","includes","forEach","location","row","col","calculateAdjacentMineCount","count","searchCol","adjacentMineCount","result","tilesClicked","tiles","initialState","Tile","_ref","tile","onClick","react_default","a","createElement","style","fontWeight","backgroundColor","Row","tileRow","map","components_Tile","Gameboard","resultMessage","resetGame","tileRows","idx","components_Row","key","Fragment","className","id","GameboardContainer","connect","state","ownProps","dispatch","type","clickTile","App","Container","es_Row","Col","containers_GameboardContainer","Component","Boolean","window","hostname","match","store","createStore","arguments","undefined","action","newTiles","newRow","Object","assign","clickedTile","contagiousClick","nextCol","newTilesClicked","newResult","totalTileCount","render","es","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"mMAIMA,EAAuB,WAG3B,IADA,IAAIC,EAAe,GACVC,EAAI,EAAGA,EANH,GAMiBA,IAAK,CACjCD,EAAaE,KAAK,IAClB,IAAK,IAAIC,EAAI,EAAGA,EATJ,GASmBA,IAC7BH,EAAaC,GAAGC,KAAK,CAAEE,cAAc,EAAOC,SAAS,IAMzD,IADA,IAAIC,EAAgB,GACbA,EAAcC,OAdP,IAc2B,CACvC,IAAIC,EAAoBC,KAAKC,MAAM,IAAAD,KAAKE,UACnCL,EAAcM,SAASJ,IAC1BF,EAAcJ,KAAKM,GAGvBF,EAAcO,QAAQ,SAAAC,GACpB,IAAIC,EAAMN,KAAKC,MAAMI,EAvBT,IAwBRE,EAAMF,EAxBE,GAwBSC,EACrBf,EAAae,GAAKC,GAAKZ,cAAe,IAwCxC,IApCA,IAAMa,EAA6B,SAACF,EAAKC,GAGvC,IAFA,IAAIE,EAAQ,EAEHC,EAAYH,EAAM,EAAGG,EAAYH,EAAM,EAAGG,IAE/CnB,EAAae,EAAM,IACnBf,EAAae,EAAM,GAAGI,IACtBnB,EAAae,EAAM,GAAGI,GAAWf,cAEjCc,IAIJ,IAAK,IAAIC,EAAYH,EAAM,EAAGG,EAAYH,EAAM,EAAGG,IAE/CnB,EAAae,IACbf,EAAae,GAAKI,IAClBnB,EAAae,GAAKI,GAAWf,cAE7Bc,IAIJ,IAAK,IAAIC,EAAYH,EAAM,EAAGG,EAAYH,EAAM,EAAGG,IAE/CnB,EAAae,EAAM,IACnBf,EAAae,EAAM,GAAGI,IACtBnB,EAAae,EAAM,GAAGI,GAAWf,cAEjCc,IAIJ,OAAOA,GAGAH,EAAM,EAAGA,EAhEL,GAgEqBA,IAChC,IAAK,IAAIC,EAAM,EAAGA,EAlEN,GAkEuBA,IACjChB,EAAae,GAAKC,GAAKI,kBAAoBH,EACzCF,EACAC,GAKN,MAAO,CAAEK,OAAQ,GAAIC,aAAc,EAAGC,MAAOvB,IAG3CwB,EAAezB,4EC7CJ0B,EA9BF,SAAAC,GAA+B,IAA5BC,EAA4BD,EAA5BC,KAAMC,EAAsBF,EAAtBE,QAASP,EAAaK,EAAbL,OACzBD,EACFO,EAAKP,kBAAoB,EAAIO,EAAKP,kBAAoB,GACxD,OAAKO,EAAKtB,SAAsB,KAAXgB,EAWjBQ,EAAAC,EAAAC,cAAA,MACEC,MAAO,CACLC,WAAYN,EAAKP,kBAAoB,EAAI,OAAS,SAClDc,gBAAiBP,EAAKvB,aAClB,UACW,QAAXiB,EACA,UACA,YAGLM,EAAKvB,aAAe,IAAMgB,GAnB7BS,EAAAC,EAAAC,cAAA,MACEH,QAASA,EACTI,MAAO,CACLE,gBAAiB,cCMZC,EAbH,SAAAT,GAAuC,IAApCU,EAAoCV,EAApCU,QAASrB,EAA2BW,EAA3BX,IAAKa,EAAsBF,EAAtBE,QAASP,EAAaK,EAAbL,OAChCE,EAAQa,EAAQC,IAAI,SAACV,EAAMX,GAAP,OACtBa,EAAAC,EAAAC,cAACO,EAAD,CACEX,KAAMA,EACNC,QAAS,WACQ,KAAXP,GAAeO,EAAQb,EAAKC,IAElCK,OAAQA,MAGZ,OAAOQ,EAAAC,EAAAC,cAAA,UAAKR,ICoBCgB,EA9BG,SAAAb,GAA2C,IAWvDc,EAXejB,EAAwCG,EAAxCH,MAAOK,EAAiCF,EAAjCE,QAASP,EAAwBK,EAAxBL,OAAQoB,EAAgBf,EAAhBe,UACvCC,EAAWnB,EAAMc,IAAI,SAACD,EAASO,GAAV,OACvBd,EAAAC,EAAAC,cAACa,EAAD,CACER,QAASA,EACTS,IAAKF,EACL5B,IAAK4B,EACLf,QAASA,EACTP,OAAQA,MAOZ,MAFe,SAAXA,IAAmBmB,EAAgB,wBACxB,QAAXnB,IAAkBmB,EAAgB,YAEpCX,EAAAC,EAAAC,cAACF,EAAAC,EAAMgB,SAAP,KACEjB,EAAAC,EAAAC,cAAA,MAAIgB,UAAU,QAAd,eACAlB,EAAAC,EAAAC,cAAA,SAAOgB,UAAU,uBAAuBL,KACvCrB,GACCQ,EAAAC,EAAAC,cAAA,MAAIiB,GAAG,SAASD,UAAU,QACvBP,GAKLX,EAAAC,EAAAC,cAAA,UAAQH,QAAS,kBAAMa,MAAvB,WCDSQ,EALYC,YAlBH,SAACC,EAAOC,GAC9B,MAAO,CACL7B,MAAO4B,EAAM5B,MACbF,OAAQ8B,EAAM9B,SAIS,SAACgC,EAAUD,GACpC,MAAO,CACLxB,QAAS,SAACb,EAAKC,GACbqC,ECdmB,SAACtC,EAAKC,GAAN,MAAe,CACtCsC,KAAM,aACNvC,MACAC,ODWauC,CAAUxC,EAAKC,KAE1ByB,UAAW,WACTY,ECX0B,CAC9BC,KAAM,kBDemBJ,CAGzBX,GENaiB,mLAZX,OACE3B,EAAAC,EAAAC,cAAC0B,EAAA,EAAD,KACE5B,EAAAC,EAAAC,cAAC2B,EAAA,EAAD,KACE7B,EAAAC,EAAAC,cAAC4B,EAAA,EAAD,CAAKZ,UAAU,IACblB,EAAAC,EAAAC,cAAC6B,EAAD,gBANMC,aCOEC,QACW,cAA7BC,OAAOjD,SAASkD,UAEe,UAA7BD,OAAOjD,SAASkD,UAEhBD,OAAOjD,SAASkD,SAASC,MACvB,2DCVN,IAAMC,EAAQC,YRuES,WAAkC,IAAjChB,EAAiCiB,UAAA7D,OAAA,QAAA8D,IAAAD,UAAA,GAAAA,UAAA,GAAzB5C,EAAc8C,EAAWF,UAAA7D,OAAA,EAAA6D,UAAA,QAAAC,EACvD,OAAQC,EAAOhB,MACb,IAAK,aAEH,IAAIiB,EAAW,GACfpB,EAAM5B,MAAMV,QAAQ,SAAAE,GAClB,IAAIyD,EAAS,GACbzD,EAAIF,QAAQ,SAAAc,GAAI,OAAI6C,EAAOtE,KAAKuE,OAAOC,OAAO,GAAI/C,MAClD4C,EAASrE,KAAKsE,KAGhB,IAAIG,EAAcJ,EAASD,EAAOvD,KAAKuD,EAAOtD,MAG9C,SAAU4D,EAAgB7D,EAAKC,GAE7B,GACGuD,EAASxD,IACTwD,EAASxD,GAAKC,KACfuD,EAASxD,GAAKC,GAAKX,UAMAkE,EAASxD,GAAKC,GACpBX,SAAU,EAGoB,IAAzCkE,EAASxD,GAAKC,GAAKI,mBAAyB,CAE9C,IAAK,IAAIyD,EAAU7D,EAAM,EAAG6D,EAAU7D,EAAM,EAAG6D,IACzCN,EAASxD,EAAM,IACjB6D,EAAgB7D,EAAM,EAAG8D,GAI7BD,EAAgB7D,EAAKC,EAAM,GAC3B4D,EAAgB7D,EAAKC,EAAM,GAG3B,IAAK,IAAI6D,EAAU7D,EAAM,EAAG6D,EAAU7D,EAAM,EAAG6D,IACzCN,EAASxD,EAAM,IACjB6D,EAAgB7D,EAAM,EAAG8D,IA7BjC,CAiCGP,EAAOvD,IAAKuD,EAAOtD,KAItB,IADA,IAAI8D,EAAkB,EACb/D,EAAM,EAAGA,EAjIT,GAiIyBA,IAChC,IAAK,IAAIC,EAAM,EAAGA,EAnIV,GAmI2BA,IAC7BuD,EAASxD,GAAKC,GAAKX,SAASyE,IAKpC,IAAIC,EAAY,GAQhB,OANwBC,KAApBF,EACFC,EAAY,MACHJ,EAAYvE,eACrB2E,EAAY,QAGP,CACL1D,OAAQ0D,EACRzD,aAAcwD,EACdvD,MAAOgD,GAGX,IAAK,aACH,OAAOxE,IAET,QACE,OAAOoD,KQjJb8B,iBACEpD,EAAAC,EAAAC,cAACmD,EAAA,EAAD,CAAUhB,MAAOA,GACfrC,EAAAC,EAAAC,cAACoD,EAAD,OAEFC,SAASC,eAAe,SDmHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.e14e1327.chunk.js","sourcesContent":["let rowLength = 10;\nlet rowCount = 10;\nlet mineCount = 10;\n\nconst generateInitialState = () => {\n  // set up empty board\n  let initialTiles = [];\n  for (let i = 0; i < rowCount; i++) {\n    initialTiles.push([]);\n    for (let j = 0; j < rowLength; j++) {\n      initialTiles[i].push({ containsMine: false, clicked: false });\n    }\n  }\n\n  // plant mines at random locations\n  let mineLocations = [];\n  while (mineLocations.length < mineCount) {\n    let potentialLocation = Math.floor(Math.random() * (rowCount * rowLength));\n    if (!mineLocations.includes(potentialLocation)) {\n      mineLocations.push(potentialLocation);\n    }\n  }\n  mineLocations.forEach(location => {\n    let row = Math.floor(location / rowLength);\n    let col = location - row * rowLength;\n    initialTiles[row][col].containsMine = true;\n  });\n\n  // calculate adjacent mine counts for each tile\n  const calculateAdjacentMineCount = (row, col) => {\n    let count = 0;\n    // count adjacent tiles in previous row\n    for (let searchCol = col - 1; searchCol < col + 2; searchCol++) {\n      if (\n        initialTiles[row - 1] &&\n        initialTiles[row - 1][searchCol] &&\n        initialTiles[row - 1][searchCol].containsMine\n      ) {\n        count++;\n      }\n    }\n    // count adjacent tiles in current row\n    for (let searchCol = col - 1; searchCol < col + 2; searchCol++) {\n      if (\n        initialTiles[row] &&\n        initialTiles[row][searchCol] &&\n        initialTiles[row][searchCol].containsMine\n      ) {\n        count++;\n      }\n    }\n    // count adjacent tiles in next row\n    for (let searchCol = col - 1; searchCol < col + 2; searchCol++) {\n      if (\n        initialTiles[row + 1] &&\n        initialTiles[row + 1][searchCol] &&\n        initialTiles[row + 1][searchCol].containsMine\n      ) {\n        count++;\n      }\n    }\n\n    return count;\n  };\n\n  for (let row = 0; row < rowCount; row++) {\n    for (let col = 0; col < rowLength; col++) {\n      initialTiles[row][col].adjacentMineCount = calculateAdjacentMineCount(\n        row,\n        col\n      );\n    }\n  }\n\n  return { result: \"\", tilesClicked: 0, tiles: initialTiles };\n};\n\nlet initialState = generateInitialState();\n\nexport const reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"CLICK_TILE\":\n      // make copy of tiles object to avoid mutating current state\n      let newTiles = [];\n      state.tiles.forEach(row => {\n        let newRow = [];\n        row.forEach(tile => newRow.push(Object.assign({}, tile)));\n        newTiles.push(newRow);\n      });\n\n      let clickedTile = newTiles[action.row][action.col];\n\n      // recursively click clicked tile and all adjacent tiles until hitting wall or tile adjacent to a mine\n      (function contagiousClick(row, col) {\n        // if coordinate isn't on board or has been clicked, return\n        if (\n          !newTiles[row] ||\n          !newTiles[row][col] ||\n          newTiles[row][col].clicked\n        ) {\n          return;\n        }\n\n        // click new tile\n        let newClickedTile = newTiles[row][col];\n        newClickedTile.clicked = true;\n\n        // if tile has no adjacent mines, attempt to click on adjacent tiles\n        if (newTiles[row][col].adjacentMineCount === 0) {\n          // click on adjacent tiles in previous row\n          for (let nextCol = col - 1; nextCol < col + 2; nextCol++) {\n            if (newTiles[row - 1]) {\n              contagiousClick(row - 1, nextCol);\n            }\n          }\n          // click on adjacent tiles in current row\n          contagiousClick(row, col - 1);\n          contagiousClick(row, col + 1);\n\n          // click on adjacent tiles in next row\n          for (let nextCol = col - 1; nextCol < col + 2; nextCol++) {\n            if (newTiles[row + 1]) {\n              contagiousClick(row + 1, nextCol);\n            }\n          }\n        }\n      })(action.row, action.col);\n\n      // update click count\n      let newTilesClicked = 0;\n      for (let row = 0; row < rowCount; row++) {\n        for (let col = 0; col < rowLength; col++) {\n          if (newTiles[row][col].clicked) newTilesClicked++;\n        }\n      }\n\n      // check for win or loss\n      let newResult = \"\";\n      let totalTileCount = rowCount * rowLength;\n      if (newTilesClicked === totalTileCount - mineCount) {\n        newResult = \"win\";\n      } else if (clickedTile.containsMine) {\n        newResult = \"loss\";\n      }\n\n      return {\n        result: newResult,\n        tilesClicked: newTilesClicked,\n        tiles: newTiles\n      };\n\n    case \"RESET_GAME\":\n      return generateInitialState();\n\n    default:\n      return state;\n  }\n};\n","import React from \"react\";\n\nconst Tile = ({ tile, onClick, result }) => {\n  let adjacentMineCount =\n    tile.adjacentMineCount > 0 ? tile.adjacentMineCount : \"\";\n  if (!tile.clicked && result === \"\") {\n    return (\n      <td\n        onClick={onClick}\n        style={{\n          backgroundColor: \"#36952F\"\n        }}\n      />\n    );\n  } else {\n    return (\n      <td\n        style={{\n          fontWeight: tile.adjacentMineCount > 0 ? \"bold\" : \"normal\",\n          backgroundColor: tile.containsMine\n            ? \"#FA5757\"\n            : result === \"win\"\n            ? \"#12A3E1\"\n            : \"#AF7E4D\"\n        }}\n      >\n        {tile.containsMine ? \"X\" : adjacentMineCount}\n      </td>\n    );\n  }\n};\n\nexport default Tile;\n","import React from \"react\";\nimport Tile from \"./Tile.jsx\";\n\nconst Row = ({ tileRow, row, onClick, result }) => {\n  let tiles = tileRow.map((tile, col) => (\n    <Tile\n      tile={tile}\n      onClick={() => {\n        if (result === \"\") onClick(row, col);\n      }}\n      result={result}\n    />\n  ));\n  return <tr>{tiles}</tr>;\n};\n\nexport default Row;\n","import React from \"react\";\nimport Row from \"./Row.jsx\";\n\nconst Gameboard = ({ tiles, onClick, result, resetGame }) => {\n  let tileRows = tiles.map((tileRow, idx) => (\n    <Row\n      tileRow={tileRow}\n      key={idx}\n      row={idx}\n      onClick={onClick}\n      result={result}\n    />\n  ));\n\n  let resultMessage;\n  if (result === \"loss\") resultMessage = \"You lost. Try again?\";\n  if (result === \"win\") resultMessage = \"You win!\";\n  return (\n    <React.Fragment>\n      <h1 className=\"mt-3\">Minesweeper</h1>\n      <table className=\"Gameboard mb-3 mt-4\">{tileRows}</table>\n      {result ? (\n        <h3 id=\"result\" className=\"mb-3\">\n          {resultMessage}\n        </h3>\n      ) : (\n        false\n      )}\n      <button onClick={() => resetGame()}>Reset</button>\n    </React.Fragment>\n  );\n};\n\nexport default Gameboard;\n","import { connect } from \"react-redux\";\nimport { clickTile, resetGame } from \"../actions/index.js\";\nimport Gameboard from \"../components/Gameboard.jsx\";\n\nconst mapStateToProps = (state, ownProps) => {\n  return {\n    tiles: state.tiles,\n    result: state.result\n  };\n};\n\nconst mapDispatchToProps = (dispatch, ownProps) => {\n  return {\n    onClick: (row, col) => {\n      dispatch(clickTile(row, col));\n    },\n    resetGame: () => {\n      dispatch(resetGame());\n    }\n  };\n};\n\nconst GameboardContainer = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Gameboard);\n\nexport default GameboardContainer;\n","export const clickTile = (row, col) => ({\n  type: \"CLICK_TILE\",\n  row,\n  col\n});\n\nexport const resetGame = () => ({\n  type: \"RESET_GAME\"\n});\n","import React, { Component } from \"react\";\nimport \"./App.css\";\nimport { Container, Row, Col } from \"react-bootstrap\";\nimport GameboardContainer from \"./containers/GameboardContainer.jsx\";\n\nclass App extends Component {\n  render() {\n    return (\n      <Container>\n        <Row>\n          <Col className=''>\n            <GameboardContainer />\n          </Col>\n        </Row>\n      </Container>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport { render } from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport { createStore } from \"redux\";\nimport { reducer } from \"./reducers/tiles.js\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nconst store = createStore(reducer);\n\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}